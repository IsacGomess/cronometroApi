{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t(require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"react\"], t) : \"object\" == typeof exports ? exports[\"react-timer-hook\"] = t(require(\"react\")) : e[\"react-timer-hook\"] = t(e.react);\n}(\"undefined\" != typeof self ? self : this, e => (() => {\n  \"use strict\";\n\n  var t = {\n      156: t => {\n        t.exports = e;\n      }\n    },\n    r = {};\n  function o(e) {\n    var n = r[e];\n    if (void 0 !== n) return n.exports;\n    var s = r[e] = {\n      exports: {}\n    };\n    return t[e](s, s.exports, o), s.exports;\n  }\n  o.d = (e, t) => {\n    for (var r in t) o.o(t, r) && !o.o(e, r) && Object.defineProperty(e, r, {\n      enumerable: !0,\n      get: t[r]\n    });\n  }, o.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), o.r = e => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  };\n  var n = {};\n  return (() => {\n    o.r(n), o.d(n, {\n      default: () => l,\n      useStopwatch: () => u,\n      useTime: () => m,\n      useTimer: () => c\n    });\n    var e = o(156);\n    class t {\n      static expiryTimestamp(e) {\n        const t = new Date(e).getTime() > 0;\n        return t || console.warn(\"react-timer-hook: { useTimer } Invalid expiryTimestamp settings\", e), t;\n      }\n      static onExpire(e) {\n        const t = e && \"function\" == typeof e;\n        return e && !t && console.warn(\"react-timer-hook: { useTimer } Invalid onExpire settings function\", e), t;\n      }\n    }\n    class r {\n      static getTimeFromSeconds(e) {\n        const t = Math.ceil(e),\n          r = Math.floor(t / 86400),\n          o = Math.floor(t % 86400 / 3600),\n          n = Math.floor(t % 3600 / 60);\n        return {\n          totalSeconds: t,\n          seconds: Math.floor(t % 60),\n          minutes: n,\n          hours: o,\n          days: r\n        };\n      }\n      static getSecondsFromExpiry(e, t) {\n        const r = e - new Date().getTime();\n        if (r > 0) {\n          const e = r / 1e3;\n          return t ? Math.round(e) : e;\n        }\n        return 0;\n      }\n      static getSecondsFromPrevTime(e, t) {\n        const r = new Date().getTime() - e;\n        if (r > 0) {\n          const e = r / 1e3;\n          return t ? Math.round(e) : e;\n        }\n        return 0;\n      }\n      static getSecondsFromTimeNow() {\n        const e = new Date();\n        return e.getTime() / 1e3 - 60 * e.getTimezoneOffset();\n      }\n      static getFormattedTimeFromSeconds(e, t) {\n        const {\n          seconds: o,\n          minutes: n,\n          hours: s\n        } = r.getTimeFromSeconds(e);\n        let i = \"\",\n          a = s;\n        return \"12-hour\" === t && (i = s >= 12 ? \"pm\" : \"am\", a = s % 12), {\n          seconds: o,\n          minutes: n,\n          hours: a,\n          ampm: i\n        };\n      }\n    }\n    function s(t, r) {\n      const o = (0, e.useRef)();\n      (0, e.useEffect)(() => {\n        o.current = t;\n      }), (0, e.useEffect)(() => {\n        if (!r) return () => {};\n        const e = setInterval(() => {\n          o.current && o.current();\n        }, r);\n        return () => clearInterval(e);\n      }, [r]);\n    }\n    const i = 1e3;\n    function a(e) {\n      if (!t.expiryTimestamp(e)) return null;\n      const o = r.getSecondsFromExpiry(e),\n        n = Math.floor(1e3 * (o - Math.floor(o)));\n      return n > 0 ? n : i;\n    }\n    function c() {\n      let {\n        expiryTimestamp: o,\n        onExpire: n,\n        autoStart: c = !0\n      } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      const [u, m] = (0, e.useState)(o),\n        [l, d] = (0, e.useState)(r.getSecondsFromExpiry(u)),\n        [p, f] = (0, e.useState)(c),\n        [g, S] = (0, e.useState)(c),\n        [T, y] = (0, e.useState)(a(u)),\n        h = (0, e.useCallback)(() => {\n          t.onExpire(n) && n(), f(!1), y(null);\n        }, [n]),\n        x = (0, e.useCallback)(() => {\n          f(!1);\n        }, []),\n        v = (0, e.useCallback)(function (e) {\n          let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n          y(a(e)), S(t), f(t), m(e), d(r.getSecondsFromExpiry(e));\n        }, []),\n        F = (0, e.useCallback)(() => {\n          const e = new Date();\n          e.setMilliseconds(e.getMilliseconds() + 1e3 * l), v(e);\n        }, [l, v]),\n        b = (0, e.useCallback)(() => {\n          g ? (d(r.getSecondsFromExpiry(u)), f(!0)) : F();\n        }, [u, g, F]);\n      return s(() => {\n        T !== i && y(i);\n        const e = r.getSecondsFromExpiry(u);\n        d(e), e <= 0 && h();\n      }, p ? T : null), {\n        ...r.getTimeFromSeconds(l),\n        start: b,\n        pause: x,\n        resume: F,\n        restart: v,\n        isRunning: p\n      };\n    }\n    function u() {\n      let {\n        autoStart: t,\n        offsetTimestamp: o\n      } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      const [n, i] = (0, e.useState)(r.getSecondsFromExpiry(o, !0) || 0),\n        [a, c] = (0, e.useState)(new Date()),\n        [u, m] = (0, e.useState)(n + r.getSecondsFromPrevTime(a || 0, !0)),\n        [l, d] = (0, e.useState)(t);\n      s(() => {\n        m(n + r.getSecondsFromPrevTime(a, !0));\n      }, l ? 1e3 : null);\n      const p = (0, e.useCallback)(() => {\n          const e = new Date();\n          c(e), d(!0), m(n + r.getSecondsFromPrevTime(e, !0));\n        }, [n]),\n        f = (0, e.useCallback)(() => {\n          i(u), d(!1);\n        }, [u]),\n        g = (0, e.useCallback)(function () {\n          let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n            t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n          const o = r.getSecondsFromExpiry(e, !0) || 0,\n            n = new Date();\n          c(n), i(o), d(t), m(o + r.getSecondsFromPrevTime(n, !0));\n        }, []);\n      return {\n        ...r.getTimeFromSeconds(u),\n        start: p,\n        pause: f,\n        reset: g,\n        isRunning: l\n      };\n    }\n    function m() {\n      let {\n        format: t\n      } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      const [o, n] = (0, e.useState)(r.getSecondsFromTimeNow());\n      return s(() => {\n        n(r.getSecondsFromTimeNow());\n      }, 1e3), {\n        ...r.getFormattedTimeFromSeconds(o, t)\n      };\n    }\n    function l(t) {\n      if ((0, e.useEffect)(() => {\n        console.warn(\"react-timer-hook: default export useTimer is deprecated, use named exports { useTimer, useStopwatch, useTime } instead\");\n      }, []), t.expiryTimestamp) {\n        const e = c(t);\n        return {\n          ...e,\n          startTimer: e.start,\n          stopTimer: e.pause,\n          resetTimer: () => {}\n        };\n      }\n      const r = u(t);\n      return {\n        ...r,\n        startTimer: r.start,\n        stopTimer: r.pause,\n        resetTimer: r.reset\n      };\n    }\n  })(), n;\n})());","map":null,"metadata":{},"sourceType":"script"}